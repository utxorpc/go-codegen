// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: utxorpc/v1alpha/bitcoin/bitcoin.proto

package bitcoin

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Represents an input in a Bitcoin transaction.
type TxInput struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Txid          []byte                 `protobuf:"bytes,1,opt,name=txid,proto3,oneof" json:"txid,omitempty"`           // Hash of the previous transaction output, corresponds to txid
	ScriptSig     []byte                 `protobuf:"bytes,2,opt,name=scriptSig,proto3,oneof" json:"scriptSig,omitempty"` // Unlocking script for spending the UTXO
	Sequence      uint32                 `protobuf:"varint,3,opt,name=sequence,proto3" json:"sequence,omitempty"`        // Used for relative timelocks
	Coinbase      []byte                 `protobuf:"bytes,4,opt,name=coinbase,proto3,oneof" json:"coinbase,omitempty"`   // Coinbase transactions have this instead of txid and scriptSig
	Txinwitness   [][]byte               `protobuf:"bytes,5,rep,name=txinwitness,proto3" json:"txinwitness,omitempty"`   // Witness data for SegWit transactions
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TxInput) Reset() {
	*x = TxInput{}
	mi := &file_utxorpc_v1alpha_bitcoin_bitcoin_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TxInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TxInput) ProtoMessage() {}

func (x *TxInput) ProtoReflect() protoreflect.Message {
	mi := &file_utxorpc_v1alpha_bitcoin_bitcoin_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TxInput.ProtoReflect.Descriptor instead.
func (*TxInput) Descriptor() ([]byte, []int) {
	return file_utxorpc_v1alpha_bitcoin_bitcoin_proto_rawDescGZIP(), []int{0}
}

func (x *TxInput) GetTxid() []byte {
	if x != nil {
		return x.Txid
	}
	return nil
}

func (x *TxInput) GetScriptSig() []byte {
	if x != nil {
		return x.ScriptSig
	}
	return nil
}

func (x *TxInput) GetSequence() uint32 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

func (x *TxInput) GetCoinbase() []byte {
	if x != nil {
		return x.Coinbase
	}
	return nil
}

func (x *TxInput) GetTxinwitness() [][]byte {
	if x != nil {
		return x.Txinwitness
	}
	return nil
}

// Represents an output in a Bitcoin transaction.
type TxOutput struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         uint64                 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`              // Amount of Bitcoin in Satoshis
	ScriptPubKey  *ScriptPubKey          `protobuf:"bytes,2,opt,name=scriptPubKey,proto3" json:"scriptPubKey,omitempty"` // Locking script defining spendability
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TxOutput) Reset() {
	*x = TxOutput{}
	mi := &file_utxorpc_v1alpha_bitcoin_bitcoin_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TxOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TxOutput) ProtoMessage() {}

func (x *TxOutput) ProtoReflect() protoreflect.Message {
	mi := &file_utxorpc_v1alpha_bitcoin_bitcoin_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TxOutput.ProtoReflect.Descriptor instead.
func (*TxOutput) Descriptor() ([]byte, []int) {
	return file_utxorpc_v1alpha_bitcoin_bitcoin_proto_rawDescGZIP(), []int{1}
}

func (x *TxOutput) GetValue() uint64 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *TxOutput) GetScriptPubKey() *ScriptPubKey {
	if x != nil {
		return x.ScriptPubKey
	}
	return nil
}

// Represents a script pub key in the output.
type ScriptPubKey struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Asm           []byte                 `protobuf:"bytes,1,opt,name=asm,proto3" json:"asm,omitempty"` // Script in human-readable format
	Hex           []byte                 `protobuf:"bytes,2,opt,name=hex,proto3" json:"hex,omitempty"` // Script in hexadecimal format
	Type          []byte                 `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	Address       []byte                 `protobuf:"bytes,4,opt,name=address,proto3,oneof" json:"address,omitempty"` // Some outputs have addresses
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScriptPubKey) Reset() {
	*x = ScriptPubKey{}
	mi := &file_utxorpc_v1alpha_bitcoin_bitcoin_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScriptPubKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScriptPubKey) ProtoMessage() {}

func (x *ScriptPubKey) ProtoReflect() protoreflect.Message {
	mi := &file_utxorpc_v1alpha_bitcoin_bitcoin_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScriptPubKey.ProtoReflect.Descriptor instead.
func (*ScriptPubKey) Descriptor() ([]byte, []int) {
	return file_utxorpc_v1alpha_bitcoin_bitcoin_proto_rawDescGZIP(), []int{2}
}

func (x *ScriptPubKey) GetAsm() []byte {
	if x != nil {
		return x.Asm
	}
	return nil
}

func (x *ScriptPubKey) GetHex() []byte {
	if x != nil {
		return x.Hex
	}
	return nil
}

func (x *ScriptPubKey) GetType() []byte {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *ScriptPubKey) GetAddress() []byte {
	if x != nil {
		return x.Address
	}
	return nil
}

// Represents a transaction in the Bitcoin network.
type Transaction struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Version       uint32                 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`          // Transaction version number. Currently 1
	Vin           []*TxInput             `protobuf:"bytes,2,rep,name=vin,proto3" json:"vin,omitempty"`                   // List of transaction inputs
	Vout          []*TxOutput            `protobuf:"bytes,3,rep,name=vout,proto3" json:"vout,omitempty"`                 // List of transaction outputs
	Locktime      uint32                 `protobuf:"varint,4,opt,name=locktime,proto3" json:"locktime,omitempty"`        // Block height or timestamp when transaction is final
	Hash          []byte                 `protobuf:"bytes,5,opt,name=hash,proto3" json:"hash,omitempty"`                 // Hash of the transaction
	Blockhash     []byte                 `protobuf:"bytes,6,opt,name=blockhash,proto3,oneof" json:"blockhash,omitempty"` // Transactions reference their block
	Time          *uint32                `protobuf:"varint,7,opt,name=time,proto3,oneof" json:"time,omitempty"`          // Timestamp of the transaction
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Transaction) Reset() {
	*x = Transaction{}
	mi := &file_utxorpc_v1alpha_bitcoin_bitcoin_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Transaction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Transaction) ProtoMessage() {}

func (x *Transaction) ProtoReflect() protoreflect.Message {
	mi := &file_utxorpc_v1alpha_bitcoin_bitcoin_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Transaction.ProtoReflect.Descriptor instead.
func (*Transaction) Descriptor() ([]byte, []int) {
	return file_utxorpc_v1alpha_bitcoin_bitcoin_proto_rawDescGZIP(), []int{3}
}

func (x *Transaction) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *Transaction) GetVin() []*TxInput {
	if x != nil {
		return x.Vin
	}
	return nil
}

func (x *Transaction) GetVout() []*TxOutput {
	if x != nil {
		return x.Vout
	}
	return nil
}

func (x *Transaction) GetLocktime() uint32 {
	if x != nil {
		return x.Locktime
	}
	return 0
}

func (x *Transaction) GetHash() []byte {
	if x != nil {
		return x.Hash
	}
	return nil
}

func (x *Transaction) GetBlockhash() []byte {
	if x != nil {
		return x.Blockhash
	}
	return nil
}

func (x *Transaction) GetTime() uint32 {
	if x != nil && x.Time != nil {
		return *x.Time
	}
	return 0
}

// Represents a block in the Bitcoin blockchain.
type Block struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	Version           uint32                 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`                          // Block version number
	Previousblockhash []byte                 `protobuf:"bytes,2,opt,name=previousblockhash,proto3,oneof" json:"previousblockhash,omitempty"` // Hash of the previous block
	Merkleroot        []byte                 `protobuf:"bytes,3,opt,name=merkleroot,proto3" json:"merkleroot,omitempty"`                     // Root hash of the Merkle tree
	Time              uint32                 `protobuf:"varint,4,opt,name=time,proto3" json:"time,omitempty"`                                // Time when the block was created
	Bits              uint32                 `protobuf:"varint,5,opt,name=bits,proto3" json:"bits,omitempty"`                                // Target difficulty value
	Nonce             uint32                 `protobuf:"varint,6,opt,name=nonce,proto3" json:"nonce,omitempty"`                              // Value used for Proof-of-Work
	Tx                []*Transaction         `protobuf:"bytes,7,rep,name=tx,proto3" json:"tx,omitempty"`                                     // List of transactions included in the block
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *Block) Reset() {
	*x = Block{}
	mi := &file_utxorpc_v1alpha_bitcoin_bitcoin_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Block) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Block) ProtoMessage() {}

func (x *Block) ProtoReflect() protoreflect.Message {
	mi := &file_utxorpc_v1alpha_bitcoin_bitcoin_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Block.ProtoReflect.Descriptor instead.
func (*Block) Descriptor() ([]byte, []int) {
	return file_utxorpc_v1alpha_bitcoin_bitcoin_proto_rawDescGZIP(), []int{4}
}

func (x *Block) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *Block) GetPreviousblockhash() []byte {
	if x != nil {
		return x.Previousblockhash
	}
	return nil
}

func (x *Block) GetMerkleroot() []byte {
	if x != nil {
		return x.Merkleroot
	}
	return nil
}

func (x *Block) GetTime() uint32 {
	if x != nil {
		return x.Time
	}
	return 0
}

func (x *Block) GetBits() uint32 {
	if x != nil {
		return x.Bits
	}
	return 0
}

func (x *Block) GetNonce() uint32 {
	if x != nil {
		return x.Nonce
	}
	return 0
}

func (x *Block) GetTx() []*Transaction {
	if x != nil {
		return x.Tx
	}
	return nil
}

var File_utxorpc_v1alpha_bitcoin_bitcoin_proto protoreflect.FileDescriptor

const file_utxorpc_v1alpha_bitcoin_bitcoin_proto_rawDesc = "" +
	"\n" +
	"%utxorpc/v1alpha/bitcoin/bitcoin.proto\x12\x17utxorpc.v1alpha.bitcoin\"\xc8\x01\n" +
	"\aTxInput\x12\x17\n" +
	"\x04txid\x18\x01 \x01(\fH\x00R\x04txid\x88\x01\x01\x12!\n" +
	"\tscriptSig\x18\x02 \x01(\fH\x01R\tscriptSig\x88\x01\x01\x12\x1a\n" +
	"\bsequence\x18\x03 \x01(\rR\bsequence\x12\x1f\n" +
	"\bcoinbase\x18\x04 \x01(\fH\x02R\bcoinbase\x88\x01\x01\x12 \n" +
	"\vtxinwitness\x18\x05 \x03(\fR\vtxinwitnessB\a\n" +
	"\x05_txidB\f\n" +
	"\n" +
	"_scriptSigB\v\n" +
	"\t_coinbase\"k\n" +
	"\bTxOutput\x12\x14\n" +
	"\x05value\x18\x01 \x01(\x04R\x05value\x12I\n" +
	"\fscriptPubKey\x18\x02 \x01(\v2%.utxorpc.v1alpha.bitcoin.ScriptPubKeyR\fscriptPubKey\"q\n" +
	"\fScriptPubKey\x12\x10\n" +
	"\x03asm\x18\x01 \x01(\fR\x03asm\x12\x10\n" +
	"\x03hex\x18\x02 \x01(\fR\x03hex\x12\x12\n" +
	"\x04type\x18\x03 \x01(\fR\x04type\x12\x1d\n" +
	"\aaddress\x18\x04 \x01(\fH\x00R\aaddress\x88\x01\x01B\n" +
	"\n" +
	"\b_address\"\x95\x02\n" +
	"\vTransaction\x12\x18\n" +
	"\aversion\x18\x01 \x01(\rR\aversion\x122\n" +
	"\x03vin\x18\x02 \x03(\v2 .utxorpc.v1alpha.bitcoin.TxInputR\x03vin\x125\n" +
	"\x04vout\x18\x03 \x03(\v2!.utxorpc.v1alpha.bitcoin.TxOutputR\x04vout\x12\x1a\n" +
	"\blocktime\x18\x04 \x01(\rR\blocktime\x12\x12\n" +
	"\x04hash\x18\x05 \x01(\fR\x04hash\x12!\n" +
	"\tblockhash\x18\x06 \x01(\fH\x00R\tblockhash\x88\x01\x01\x12\x17\n" +
	"\x04time\x18\a \x01(\rH\x01R\x04time\x88\x01\x01B\f\n" +
	"\n" +
	"_blockhashB\a\n" +
	"\x05_time\"\xfe\x01\n" +
	"\x05Block\x12\x18\n" +
	"\aversion\x18\x01 \x01(\rR\aversion\x121\n" +
	"\x11previousblockhash\x18\x02 \x01(\fH\x00R\x11previousblockhash\x88\x01\x01\x12\x1e\n" +
	"\n" +
	"merkleroot\x18\x03 \x01(\fR\n" +
	"merkleroot\x12\x12\n" +
	"\x04time\x18\x04 \x01(\rR\x04time\x12\x12\n" +
	"\x04bits\x18\x05 \x01(\rR\x04bits\x12\x14\n" +
	"\x05nonce\x18\x06 \x01(\rR\x05nonce\x124\n" +
	"\x02tx\x18\a \x03(\v2$.utxorpc.v1alpha.bitcoin.TransactionR\x02txB\x14\n" +
	"\x12_previousblockhashB\xe0\x01\n" +
	"\x1bcom.utxorpc.v1alpha.bitcoinB\fBitcoinProtoP\x01Z5github.com/utxorpc/go-codegen/utxorpc/v1alpha/bitcoin\xa2\x02\x03UVB\xaa\x02\x17Utxorpc.V1alpha.Bitcoin\xca\x02\x17Utxorpc\\V1alpha\\Bitcoin\xe2\x02#Utxorpc\\V1alpha\\Bitcoin\\GPBMetadata\xea\x02\x19Utxorpc::V1alpha::Bitcoinb\x06proto3"

var (
	file_utxorpc_v1alpha_bitcoin_bitcoin_proto_rawDescOnce sync.Once
	file_utxorpc_v1alpha_bitcoin_bitcoin_proto_rawDescData []byte
)

func file_utxorpc_v1alpha_bitcoin_bitcoin_proto_rawDescGZIP() []byte {
	file_utxorpc_v1alpha_bitcoin_bitcoin_proto_rawDescOnce.Do(func() {
		file_utxorpc_v1alpha_bitcoin_bitcoin_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_utxorpc_v1alpha_bitcoin_bitcoin_proto_rawDesc), len(file_utxorpc_v1alpha_bitcoin_bitcoin_proto_rawDesc)))
	})
	return file_utxorpc_v1alpha_bitcoin_bitcoin_proto_rawDescData
}

var file_utxorpc_v1alpha_bitcoin_bitcoin_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_utxorpc_v1alpha_bitcoin_bitcoin_proto_goTypes = []any{
	(*TxInput)(nil),      // 0: utxorpc.v1alpha.bitcoin.TxInput
	(*TxOutput)(nil),     // 1: utxorpc.v1alpha.bitcoin.TxOutput
	(*ScriptPubKey)(nil), // 2: utxorpc.v1alpha.bitcoin.ScriptPubKey
	(*Transaction)(nil),  // 3: utxorpc.v1alpha.bitcoin.Transaction
	(*Block)(nil),        // 4: utxorpc.v1alpha.bitcoin.Block
}
var file_utxorpc_v1alpha_bitcoin_bitcoin_proto_depIdxs = []int32{
	2, // 0: utxorpc.v1alpha.bitcoin.TxOutput.scriptPubKey:type_name -> utxorpc.v1alpha.bitcoin.ScriptPubKey
	0, // 1: utxorpc.v1alpha.bitcoin.Transaction.vin:type_name -> utxorpc.v1alpha.bitcoin.TxInput
	1, // 2: utxorpc.v1alpha.bitcoin.Transaction.vout:type_name -> utxorpc.v1alpha.bitcoin.TxOutput
	3, // 3: utxorpc.v1alpha.bitcoin.Block.tx:type_name -> utxorpc.v1alpha.bitcoin.Transaction
	4, // [4:4] is the sub-list for method output_type
	4, // [4:4] is the sub-list for method input_type
	4, // [4:4] is the sub-list for extension type_name
	4, // [4:4] is the sub-list for extension extendee
	0, // [0:4] is the sub-list for field type_name
}

func init() { file_utxorpc_v1alpha_bitcoin_bitcoin_proto_init() }
func file_utxorpc_v1alpha_bitcoin_bitcoin_proto_init() {
	if File_utxorpc_v1alpha_bitcoin_bitcoin_proto != nil {
		return
	}
	file_utxorpc_v1alpha_bitcoin_bitcoin_proto_msgTypes[0].OneofWrappers = []any{}
	file_utxorpc_v1alpha_bitcoin_bitcoin_proto_msgTypes[2].OneofWrappers = []any{}
	file_utxorpc_v1alpha_bitcoin_bitcoin_proto_msgTypes[3].OneofWrappers = []any{}
	file_utxorpc_v1alpha_bitcoin_bitcoin_proto_msgTypes[4].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_utxorpc_v1alpha_bitcoin_bitcoin_proto_rawDesc), len(file_utxorpc_v1alpha_bitcoin_bitcoin_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_utxorpc_v1alpha_bitcoin_bitcoin_proto_goTypes,
		DependencyIndexes: file_utxorpc_v1alpha_bitcoin_bitcoin_proto_depIdxs,
		MessageInfos:      file_utxorpc_v1alpha_bitcoin_bitcoin_proto_msgTypes,
	}.Build()
	File_utxorpc_v1alpha_bitcoin_bitcoin_proto = out.File
	file_utxorpc_v1alpha_bitcoin_bitcoin_proto_goTypes = nil
	file_utxorpc_v1alpha_bitcoin_bitcoin_proto_depIdxs = nil
}
